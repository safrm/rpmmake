#!/bin/sh
#rpmmake - fast script to create rpm package inside the git repo without being root - https://github.com/safrm/rpmmake
#author: Miroslav Safr <miroslav.safr@gmail.com>
#
#usage1: <my-project>$ rpmmake  ................... builds rpms from <my-project>/<my-project>.spec in <my-project>/rpm rootdir 
#                                                   requires <my-project>/<my-project>.spec and tags as x.y.z
#usage2: rpmmake  /<my-path>/<my-project> ......... builds rpms from /<my-path>/<my-project>/<my-project>.spec in /<my-path>/<my-project>/rpm rootdir
#usage3: <some-other-name>$ rpmmake -b <my-project> ...... project name is taken from argument <my-project> instead of directory name
VERSION=NA                                                                   
VERSION_DATE=NA

usage() {
    echo "usage: `basename $0` [<path_to_project_git_dir>] [-b <basename>] "
    echo "fast script to create rpm package inside the git repo without being root - https://github.com/safrm/rpmmake"
    echo ""
    echo "<path_to_project_git_dir>  path to git directory (empty uses current directory)"
    echo "args:"
    echo "  -b  | --basename <my-project>    project name is taken from argument <my-project> instead of directory name"
    echo "  -sv | --set-version <my-version> project version is taken from argument <my-version> instead of git tag"
    echo "  -sr | --set-release <my-release> project release is taken from argument <my-release> instead of spec file"
    echo "  -sp | --spec-version             prefer version from spec file over git tag"
    echo "  -gn | --gpg-name <gpg-name>      set custom gpg name for signing by name"
    echo "  -gk | --gpg-key <gpg-key>        set custom gpg name for signing by key"                
    echo "  -ns | --nosign                   do not sign the package"
    echo "  -ne | --noexpect                 do not use expect to enter passphrase"
    echo "  -nv | --noverify                 do not run package verification"
    echo "  -pp | --passphrase <passphrase>  pass passphrase or use export PASSPHRASE=<pp>"
    echo "  -v  | --verbose                  prints more output"
    echo "  -V  | --version                  prints version of scripts"
    echo "  -h  | --help                     prints this help"
    echo ""
    echo "rpmmake: ${VERSION} ${VERSION_DATE}"
}
SIGN=1
VERIFY=1
EXPECT=1
USE_VERSION_FROM_SPEC=0

while [ $# -gt 0 ]; do
  case "$1" in
    -b|--basename) shift
               CUSTOM_BASENAME=$1    #clone directory has different name than project
               ;;
    -sp|--spec-version)
		USE_VERSION_FROM_SPEC=1
		;;
    -sv|--set-version) shift
               RPM_VERSION=$1           #custom version
               ;;
    -sr|--set-release) shift
               RPM_RELEASE=$1           #custom release
               ;;
    -ns|--nosign)
               SIGN=0
               ;;
    -gn|--gpg-name) shift
		GPG_NAME=$1
		;;
    -gk|--gpg-key) shift
		GPG_KEY=$1
		GPG_NAME=`gpg --list-keys | grep "$GPGKEY" -1 | grep uid | sed "s/uid *//"`
		if [ -z "$GPG_NAME" ]; then echo "wrong gpg key $GPG_KEY"; exit 1; fi
		;;
    -nv|--noverify)
               VERIFY=0
               ;;
    -ne|--noexpect)
               EXPECT=0
               ;;
    -pp | --passphrase) shift
              PASSPHRASE=$1
               ;;
    -v | --verbose)
		VERBOSE="--verbose"
		;;
    -V | --version) echo "`basename $0` ${VERSION} ${VERSION_DATE}"
                  exit 0
                  ;;  
    -h | --help ) usage 
		  exit 0
                  ;;
	* )       ORIG_PWD_DIR=`pwd`; cd $1   #from different directory
			   ;; 
  esac
  shift
done

#basename from 
PWD=`pwd`
BASENAME=`basename "$PWD"`
[ "x$CUSTOM_BASENAME" != "x" ] && BASENAME=$CUSTOM_BASENAME
if [ ! -f $BASENAME.spec ]
then
    echo "File $PWD/$BASENAME.spec does not exists" 
    exit 1
fi

#version autodetection from git if not set by args
if [ "x$RPM_VERSION" = "x" ]
then
    RPM_VERSION=`git describe --abbrev=0 2> /dev/null`
    if [ $USE_VERSION_FROM_SPEC -eq 1 ] || [ "x$RPM_VERSION" = "x" ]; then
	RPM_VERSION=`cat  $BASENAME.spec  |grep -E "^Version:" | awk -F " " '{print $2}'`
    fi
fi
if [ "x$RPM_VERSION" = "x" ]
then
    echo "error: version not detected"
    exit 1
fi
echo "preparing $BASENAME-$RPM_VERSION $RPM_RELEASE"

#cleaning
rm -fr ./rpm
mkdir -p -m 0777 rpm/SOURCES rpm/BUILD rpm/SRPMS rpm/RPMS/i386 

#update version in spec from git tag
sed  "s/^Version:.*/Version:    ${RPM_VERSION}/" ./$BASENAME.spec > rpm/SOURCES/$BASENAME-$RPM_VERSION.spec

#update release in spec from args
if [ "x$RPM_RELEASE" != "x" ]; then
	sed -i".bkp" "s/^Release:.*/Release:     ${RPM_RELEASE}/" rpm/SOURCES/$BASENAME-$RPM_VERSION.spec && rm -f rpm/SOURCES/$BASENAME-$RPM_VERSION.spec.bkp
fi

#use changelog from edited file
if [ ! -e ./$BASENAME.changes ]; then
#or generate changelog automatically 
  rpmmake-changelog -b $BASENAME 
fi
cat ./$BASENAME.changes >> rpm/SOURCES/$BASENAME-$RPM_VERSION.spec

#update release no automaticaly
#NEW_RELEASE=$[`awk '/Release/ {print $2}' $BASENAME.spec`+1]

#qt clear current sources
if ls -U *.pro > /dev/null 2>&1; then
    qmake && make distclean
fi

#add rpm exclude
#for old tar
TAR_MIN_VERSION=`tar --version | head -1 |  awk -F"[ .]" ' { print   $5 }'`
if [ $TAR_MIN_VERSION -lt 21 ]
then
  echo "old tar $TAR_MIN_VERSION "
  tar --exclude=.gitignore --exclude=.git/* --exclude=build/* --exclude=debian/* --exclude=*.tar.bz2 --exclude=rpm/* $VERBOSE -cjf rpm/SOURCES/$BASENAME-$RPM_VERSION.tar.bz2  ./
else
  echo "new tar $TAR_MIN_VERSION "
  tar --exclude-vcs --exclude=build/* --exclude=debian/* --exclude=*.tar.bz2 --exclude=rpm/* $VERBOSE -cjf rpm/SOURCES/$BASENAME-$RPM_VERSION.tar.bz2  ./
fi
echo "tar ball OK"

if [ ! -z "$GPG_NAME" ]; then
#	GPG_NAME_ARG="--define=_gpg_name '$GPG_NAME' --define=_signature gpg"
	echo "using gpg_name $GPG_NAME"
fi

export PASSPHRASE=$PASSPHRASE
#default sign from ~/.rpmmacros
#%_signature     gpg
#%_gpg_name      name or key

rpmbuild -ba ./rpm/SOURCES/$BASENAME-$RPM_VERSION.spec --define="_topdir $PWD/rpm" $VERBOSE 
if [ $? != 0 ]; then
   echo "rpmbuild failed, exiting..."
   exit 1
fi
cd $PWD

#signing
if [ $SIGN -eq 1 ]; then
	PACKAGES=`find $PWD/rpm -type f -printf '%p\n' | grep -i -E -Z '\.(rpm)$'`
	echo "${PACKAGES}" | \
	{ while IFS='\n' read -r ENTRY ;
	do
		echo "signing> $SIGN_NAME KEY:$GPGKEY FILE:$ENTRY"
		if [ $EXPECT -eq 1 ]; then
			rpmmake-expect rpm --addsign $VERBOSE -D "_signature gpg" -D "_gpg_name $GPG_NAME"  "$ENTRY"
		else
			rpm --addsign $VERBOSE -D "_signature gpg" -D "_gpg_name $GPG_NAME" "$ENTRY"
		fi
	        rpm --checksig $VERBOSE "$ENTRY"
	done
	}
fi

#verification
if [ $VERIFY = 1 ] 
then
    #to not have them 2x
    PACKAGES=`find $PWD/rpm -type f -name "*.rpm" -not -name "*.src.rpm"`
    for PACKAGE in $PACKAGES ; do

    rpm -qip $PACKAGE
    if [ $? != 0 ] 
    then
      echo "problem with $PACKAGE exiting...";
      exit 1;
    fi
done
fi
cd $ORIG_PWD_DIR

